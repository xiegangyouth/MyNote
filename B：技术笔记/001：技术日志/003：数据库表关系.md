# 1、引言

我们在同一数据库创建的表时候，很多时候会出现相同数据的冗余问题，也就是说几个id会有一个或者同n个相同字段，这样就导致数据表结构数据重复冗余。

一旦要修改其中一个相同的字段信息，其他跟他相同字段的信息也都要同步修改，这就增加了很多工作量，特别是如果要处理大量数据的时候所以需要有一种解决方式来处理这种显而易见的问题。

例如：

| **id** | **name**  | **gender** | **dep_name** | **dep_desc**   |
| ------ | --------- | ---------- | ------------ | -------------- |
| **1**  | **jason** | **male**   | **外交部**   | **形象代言人** |
| **2**  | **egon**  | **male**   | **教学部**   | **教书育人**   |
| **3**  | **kevin** | **male**   | **教学部**   | **教书育人**   |
| **4**  | **tank**  | **male**   | **教学部**   | **教书育人**   |
| **5**  | **jerry** | **female** | **技术部**   | **技术负责人** |

上表id值为2、3、4的人员属于同一个字段名（部门）教育部，部门描述也是一样，一旦要修改部门名称或者部门描述，2、3、4均要同时进行修改。

解决方法：拆分为2个表，通过dep_id映射字段将两张表进行关联，若修改部门表字段dep_name或dep_desc，人员表不受影响。

```sql
+----+-------+--------+--------+
| id | name  | gender | dep_id |
+----+-------+--------+--------+
|  1 | jason | male   |      1 |
|  2 | egon  | male   |      2 |
|  3 | kevin | male   |      2 |
|  4 | tank  | male   |      2 |
|  5 | jerry | female |      3 |
+----+-------+--------+--------+

+----+-----------+--------------------------+
| id | dep_name  | dep_desc                 |
+----+-----------+--------------------------+
|  1 | 外交部     | 形象代言人                 |
|  2 | 教育部     | 教书育人                   |
|  3 | 技术部     | 技术负责人                 |
+----+-----------+--------------------------+
```

---

数据库实体间存在3种对应关系：

+ `一对一关系`：一个人对应一个身份证号码，数据字段设置 unique
+ `一对多关系`：一个家庭有多个人，一般通过外键来实现
+ `多对多关系`：一个学生有多门课程，一个课程有很多学生，一般通过第三个表来实现关联

# 2、一对一

A表的字段与B表中的某一唯一字段形成一对一的关联

```mysql
# 我们可以通过客户表和投保人之间的关系来描述一对一
保险销售人员有个客户表，在每天的不断努力经营客户之下，促进了多个客户成为了投保人，这个多个投保人作为一张投保人表，他们之间的关系可以说是一对一关系：
或者说是一种类似于集合的父集与子集的关系。
mysql> create table customer(
    -> id int primary key auto_increment,
    -> name char(16),
    -> age int,
    -> sex enum('male','female','other'),
    -> wechart char(16)
    -> );

mysql> create table holder(          # 创建投保人表
    -> id int primary key auto_increment,
    -> name char(16),
    -> holder_price int,
    -> customer_id int unique,       # 将客户id设为唯一，因为客户表中客户id必须唯一
    -> foreign key(customer_id) references customer(id) on update cascade on delete cascade
    -> );   # 客户id与客户表中id进行关联。同步改删
--------------------------------------------------
插入数据：（先插入客户表（被关联），再插入投保人表）
mysql> insert into customer(name,age,sex,wechart) values
    -> ('张三丰',18,'male','17375898'),
    -> ('张小凡',16,'male','65652456'),
    -> ('陆雪琪',17,'female','62612384'),
    -> ('秦祥林',25,'male','545654655'),
    -> ('至尊宝',999,'male','66666666'),
    -> ('韦小宝',30,'male','475247124');

mysql> insert into holder(name,holder_price,customer_id) values
    -> ('张小凡',5000000,2),
    -> ('陆雪琪',10000000,3),
    -> ('韦小宝',990000,6);

# 查看结果：
mysql> select * from customer;
+----+-----------+------+--------+-----------+
| id | name      | age  | sex    | wechart   |
+----+-----------+------+--------+-----------+
|  1 | 张三丰    |   18 | male   | 17375898  |
|  2 | 张小凡    |   16 | male   | 65652456  |
|  3 | 陆雪琪    |   17 | female | 62612384  |
|  4 | 秦祥林    |   25 | male   | 545654655 |
|  5 | 至尊宝    |  999 | male   | 66666666  |
|  6 | 韦小宝    |   30 | male   | 475247124 |
+----+-----------+------+--------+-----------+
mysql> select * from holder;
+----+-----------+--------------+-------------+
| id | name      | holder_price | customer_id |
+----+-----------+--------------+-------------+
|  1 | 张小凡    |      5000000 |           2 |
|  2 | 陆雪琪    |     10000000 |           3 |
|  3 | 韦小宝    |       990000 |           6 |
+----+-----------+--------------+-------------+
```

# 3、一对多

 foreign key 会将本表中的一个字段与另外一个表的字段（通常是主键字段）进行关联。

```mysql
在创建表时，必须先建被关联的表dep，才能建关联表emp
create database foreign_ts;  # 创建数据库
use foreign_ts;                    # 进入数据库
# 先创建被关联表：
create table dep(
    id int primary key auto_increment,         # 设置主键，自增长
    dep_name char(16),
    dep_desc char(16)
    );

# 再创建关联表emp：
create table emp(
    id int primary key auto_increment,        # 设置主键，自增长
    name char(16),
    gender enum('male','female','others'),
    dep_id int,
    foreign key(dep_id) references dep(id)    # 外键  关联
    on update cascade                # 同步更新
    on delete cascade                # 同步删除
    );

# 插入数据：
在插入记录时，必须先插入被关联的表dep，才能插关联表emp
insert into dep(dep_name,dep_desc) values
 ('外交部','形象代言人'),('教育部','教书育人'),('技术部','技术能力有限部门');

insert into emp(name,gender,dep_id) values
('jason','male',1),
('egon','male',2),
('kevin','male',2),
('tank','male',2),
('jerry','female',3);
```

# 4、多对多

一对多是A表中多个字段关联B表中一个字段。

而多对多就是在此基础上B表中也有多个字段关联A表中一个字段。

此时如果依然以上面一对多的形式去创建表格的话，就会出现互相矛盾的问题，也就是我再关联你的时候你还没有被创建的情况。

```mysql
# 图书表与作者表之间的关系
"""
仍然站在两张表的角度：
1.站在图书表：一本书可以有多个作者
2.站在作者表：一个作者可以写多本书
双方都能一条数据对应对方多条记录，这种关系就是多对多！
"""
# 先来想如何创建表？图书表需要有一个外键关联作者，作者也需要有一个外键字段关联图书。问题来了，先创建谁都不合适！如何解决？
# 建立第三张表，该表中有一个字段fk左表的id，还有一个字段是fk右表的id
----------------------------------
先将2个表建起了：
mysql> create table author(                  #建作者表，id和name足以
    -> id int primary key auto_increment,
    -> name char(16)
    -> );

mysql> create table book(                    # 建书表，id、书名、价格
    -> id int primary key auto_increment,
    -> title char(16),
    -> price int
    -> );
插入表数据：
mysql> insert into author(name) values
    -> ('唐家三少'),
    -> ('金庸'),
    -> ('萧鼎')
    -> ;

mysql> insert into book(title,price) values
    ->     ('光之子',99),
    ->     ('冰火魔厨',88),
    ->     ('斗罗大陆',77),
    ->     ('倚天屠龙记',98),
    ->     ('神雕侠侣',96),
    ->     ('诛仙',100);
mysql> select* from author;    # 查看建表结果
+----+--------------+
| id | name         |
+----+--------------+
|  1 | 唐家三少     |
|  2 | 金庸         |
|  3 | 萧鼎         |
+----+--------------+
mysql> select* from book;      # 查看建表结果
+----+-----------------+-------+
| id | title           | price |
+----+-----------------+-------+
|  1 | 光之子          |    99 |
|  2 | 冰火魔厨        |    88 |
|  3 | 斗罗大陆        |    77 |
|  4 | 倚天屠龙记      |    98 |
|  5 | 神雕侠侣        |    96 |
|  6 | 诛仙            |   100 |
+----+-----------------+-------+
--------------------------------------------------------------------------
建立第三张表，这张表作用就是关联author表和book表。
mysql> create table book2author(
    -> id int primary key auto_increment,
    -> book_id int,
    -> foreign key(book_id) references book(id) on update cascade on delete cascade,   # 设置外键
    -> author_id int,
    -> foreign key(author_id) references author(id) on update cascade on delete cascade   # 设置外键
    -> );
# 插入关联数据
mysql> insert into book2author(book_id,author_id) values
    -> (1,1),
    -> (2,1),
    -> (3,1),
    -> (4,2),
    -> (5,2),
    -> (6,3);
# 查看结果：
mysql> select * from book2author;
+----+---------+-----------+
| id | book_id | author_id |
+----+---------+-----------+
|  1 |       1 |         1 |
|  2 |       2 |         1 |
|  3 |       3 |         1 |
|  4 |       4 |         2 |
|  5 |       5 |         2 |
|  6 |       6 |         3 |
+----+---------+-----------+

这样就将book表和author表之间通过第三张表建立了多对多外键关联。
```

