# 1.冒泡排序思想

冒泡排序，该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列（）。

例如，对无序表`{49，38，65，97，76，13，27，49}`进行升序排序的具体实现过程如图1 所示：

![1.png](https://i.loli.net/2020/11/15/mjQkZzH9yaT2cfr.png)

如图 1 所示是对无序表的第一次起泡排序，最终将无序表中的最大值 97 找到并存储在表的最后一个位置。

由于 97 已经判断为最大值，所以第二次冒泡排序时就需要找出除 97 之外的无序表中的最大值，比较过程和第一次完全相同。

![2.png](https://i.loli.net/2020/11/15/v4uTo3eYIRhrLAB.png)

经过第二次冒泡，最终找到了除 97 之外的又一个最大值 76，比较过程完全一样，这里不再描述。

> 通过一趟趟的比较，一个个的“最大值”被找到并移动到相应位置，直到检测到表中数据已经有序，或者比较次数等同于表中含有记录的个数，排序结束，这就是冒泡排序。（==大数下沉，小数上冒==）

# 2.核心代码

~~~c
//冒泡排序（升序）
void BubbleSort(int a[] , int length){
    int i,j,tmp;
    for(i=0;i<length-1;i++){//n个数的数列总共需要执行n-1趟冒泡排序
        for(j=0;j<length-1-i;j++){//每一趟扫描到a[n-i-2]与a[n-i-1]比较为止
            if(a[j] > a[j+1]){//后一位数<前一位数，二者交换位置
                tmp=a[j];
                a[j]=a[j+1];
                a[j+1]=tmp;
            }
        }
    }
}
~~~

注：每一趟排序“最大值”均被放到最右侧
如第一趟97被置于最右侧8号位置（97大小顺序在第一趟被确定，故接下来的排序97不参与排序）→第二趟76被置于最右侧7号位置（8号位置97不参与）,同时76大小顺序被确定，不参与接下来排序，故第3趟“最大值”65依次比较之后将被置于6号位置
这正是for(j=0;j<`length-1-i`;j++)的原因

# 3.双向冒泡排序

## 算法思想

1. 首选从左至右比较相邻元素值，若前一个元素比后一个元素大即交换；

2. 然后从右往左比较相邻元素值，遇到逆序（即a[j]<a[j-1]）即交换；

3. 重复执行操作1和操作2：奇数趟时从左向右进行比较和交换（大数下沉），偶数趟时从右向左进行比较和交换（小数上冒）；
4. 当从左端开始遍历的指针与从右端开始遍历的指针相遇时，排序结束。

## 核心代码

~~~c
void BubblieSort2(int a[] , int length){
    int low=0;	//	未完成排序元素中的最小下标
    int high=length-1;	//未完成排序元素中的最大下标
    int flag=1;	//标记当前趟是否进行了交换
    while(low <high && flag){	//当flag为0时说明没有了逆序，循环跳出
        flag=0;	//每趟初始时flag设为0
        /*正向冒泡：begin*/
        for(i=low;i<high;i++){
            if(a[i]>a[i+1]){
                swap(a[i],a[i+1]);	//交换
                flag=1;
            }
        }
        high--;
        /*正向冒泡：end*/
        /*反向冒泡：begin*/
        for(i=high;i>low;i--){
            if(a[i]<a[i-1]){
                swap(a[i],a[i-1]);	//交换
                flag=1;
            }
        }
        low++;
        /*反向冒泡：end*/
    }
}
~~~

注：flag的作用

![Snipaste_2020-11-15_17-45-16.png](https://i.loli.net/2020/11/15/CwhaOGs2Rt7ML4z.png)